<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet"
 href="https://unpkg.com/leaflet/dist/leaflet.css"/>

<style>
html,body{margin:0;height:100%;}
#map{height:100%;}

.signalWrap{
 display:flex;
 flex-direction:column;
 align-items:center;
 transform-origin:center center;
}

.timeText{
 font-size:7px;
 color:white;
 text-shadow:0 0 2px black;
 margin-bottom:1px;
}

.gauge{
 width:14px;
 height:2px;
 margin-bottom:1px;
 background:#300;
}

.pedSignal{
 width:12px;
 height:28px;
 background:#111;
 border-radius:3px;
 padding:2px;
 display:flex;
 flex-direction:column;
 justify-content:space-between;
}

.light{
 width:8px;
 height:8px;
 border-radius:50%;
 background:#300;
 margin:auto;
}

.red{background:red;}
.green{background:#00ff88;}
.blink{opacity:0.2;}
</style>
</head>

<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>

const intersections={
a:{center:[36.081246,140.115064],base:"07:23:58",cycle:[34,19,61,26]},
c:{center:[36.076570,140.123876],base:"07:30:00",cycle:[76,19,21,24]},
f:{center:[36.067278,140.132438],base:"07:34:35",cycle:[80,19,31,8]},
h:{center:[36.060625,140.141941],base:"07:39:54",cycle:[79,17,36,8]}
};

const map=L.map('map').setView([36.076570,140.123876],17);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
 attribution:'© OpenStreetMap'
}).addTo(map);

function getBaseDate(str){
 const now=new Date();
 const [h,m,s]=str.split(":");
 return new Date(now.getFullYear(),now.getMonth(),now.getDate(),h,m,s);
}

function createSignal(){
 const wrap=document.createElement("div");
 wrap.className="signalWrap";

 const time=document.createElement("div");
 time.className="timeText";

 const gauge=document.createElement("div");
 gauge.className="gauge";

 const body=document.createElement("div");
 body.className="pedSignal";

 const red=document.createElement("div");
 red.className="light";
 const green=document.createElement("div");
 green.className="light";

 body.appendChild(red);
 body.appendChild(green);
 wrap.appendChild(time);
 wrap.appendChild(gauge);
 wrap.appendChild(body);

 return {wrap,red,green,gauge,time};
}

function rotatedOffsets(){
 const d=0.00013;   // ← 広げた
 const base=[[d,0],[-d,0],[0,d],[0,-d]];
 const angle=45*Math.PI/180;
 return base.map(([x,y])=>{
  const rx=x*Math.cos(angle)-y*Math.sin(angle);
  const ry=x*Math.sin(angle)+y*Math.cos(angle);
  return [rx,ry];
 });
}

const allMarkers=[];

Object.values(intersections).forEach(intersection=>{
 const offsets=rotatedOffsets();
 const baseDate=getBaseDate(intersection.base);
 const total=intersection.cycle.reduce((a,b)=>a+b,0);

 offsets.forEach((off,i)=>{
  const dir=i<2?"縦":"横";
  const s=createSignal();

  const marker=L.marker([
   intersection.center[0]+off[0],
   intersection.center[1]+off[1]
  ],{
   icon:L.divIcon({
    html:s.wrap,
    className:""
   })
  }).addTo(map);

  allMarkers.push({marker,signal:s,dir,cycle:intersection.cycle,total,baseDate});
 });
});

function getPhase(obj){
 const now=new Date();
 const diff=(now-obj.baseDate)/1000;
 const t=((diff%obj.total)+obj.total)%obj.total;
 const [v,b1,h,b2]=obj.cycle;

 if(t<v) return {type:"縦",remain:v-t,duration:v};
 if(t<v+b1) return {type:"間",remain:v+b1-t,duration:b1};
 if(t<v+b1+h) return {type:"横",remain:v+b1+h-t,duration:h};
 return {type:"間",remain:obj.total-t,duration:b2};
}

setInterval(()=>{
 allMarkers.forEach(obj=>{
  const phase=getPhase(obj);
  const s=obj.signal;

  s.red.className="light";
  s.green.className="light";

  let color="red";

  if((phase.type==="縦"&&obj.dir==="縦")||
     (phase.type==="横"&&obj.dir==="横")){
   s.green.classList.add("green");
   color="#00ff88";
   if(phase.remain<=5&&Math.floor(Date.now()/300)%2===0){
    s.green.classList.add("blink");
   }
  }else{
   s.red.classList.add("red");
   color="red";
  }

  const ratio=phase.remain/phase.duration;

  s.gauge.style.background=
   `linear-gradient(to right, ${color} ${ratio*100}%, #222 ${ratio*100}%)`;

  s.time.textContent=Math.ceil(phase.remain);
 });
},200);

const BASE_ZOOM=17;
const SCALE_PER_ZOOM=1.3;

function updateScale(){
 const zoom=map.getZoom();
 const scale=Math.pow(SCALE_PER_ZOOM,zoom-BASE_ZOOM);
 allMarkers.forEach(obj=>{
  obj.signal.wrap.style.transform=`scale(${scale})`;
 });
}

map.on("zoom",updateScale);
updateScale();

</script>
</body>
</html>
